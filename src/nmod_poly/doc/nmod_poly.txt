/*=============================================================================

    This file is part of FLINT.

    FLINT is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    FLINT is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with FLINT; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

=============================================================================*/
/******************************************************************************

    Copyright (C) 2010 William Hart

******************************************************************************/

*******************************************************************************

    Memory management

*******************************************************************************

void nmod_poly_init(nmod_poly_t poly, mp_limb_t n)

    Initialises \code{poly}. It will have coefficients modulo~$n$.

void nmod_poly_init_preinv(nmod_poly_t poly, mp_limb_t n, mp_limb_t ninv)

    Initialises \code{poly}. It will have coefficients modulo~$n$.  
    The caller supplies a precomputed inverse limb generated by 
    \code{n_preinvert_limb()}.

void nmod_poly_init2(nmod_poly_t poly, mp_limb_t n, long alloc)

    Initialises \code{poly}. It will have coefficients modulo~$n$.
    Up to \code{alloc} coefficients may be stored in \code{poly}.

void nmod_poly_init2_preinv(nmod_poly_t poly, 
                       mp_limb_t n, mp_limb_t ninv, long alloc)

    Initialises \code{poly}. It will have coefficients modulo~$n$. 
    The caller supplies a precomputed inverse limb generated by 
    \code{n_preinvert_limb()}. Up to \code{alloc} coefficients may 
    be stored in \code{poly}.

void nmod_poly_realloc(nmod_poly_t poly, long alloc)

    Reallocates \code{poly} to the given length. If the current 
    length is less than \code{alloc}, the polynomial is truncated 
    and normalised.  If \code{alloc} is zero, the polynomial is 
    cleared.

void nmod_poly_clear(nmod_poly_t poly)

    Clears the polynomial and releases any memory it used. The polynomial 
    cannot be used again until it is initialised.

void nmod_poly_fit_length(nmod_poly_t poly, long alloc)

    Ensures \code{poly} has space for at least \code{alloc} coefficients. 
    This function only ever grows the allocated space, so no data loss can 
    occur.

void _nmod_poly_normalise(nmod_poly_t poly)

    Internal function for normalising a polynomial so that the final 
    coefficient (if there are any at all) is not zero.

*******************************************************************************

    Polynomial properties

*******************************************************************************

long nmod_poly_length(const nmod_poly_t poly)

    Returns the length of the polynomial \code{poly}. The zero polynomial
    has length zero.

long nmod_poly_degree(const nmod_poly_t poly)

    Returns the degree of the polynomial \code{poly}. The zero polynomial
    is deemed to have degree~$-1$.

mp_limb_t nmod_poly_modulus(const nmod_poly_t poly)

    Returns the modulus of the polynomial \code{poly}. This will be a 
    positive integer.

mp_bitcnt_t nmod_poly_max_bits(const nmod_poly_t poly)

    Returns the maximum number of bits of any coefficient of \code{poly}.

*******************************************************************************

    Assignment and basic manipulation

*******************************************************************************

void nmod_poly_set(nmod_poly_t a, const nmod_poly_t b)

    Sets \code{a} to a copy of \code{b}.

void nmod_poly_swap(nmod_poly_t poly1, nmod_poly_t poly2)

    Efficiently swaps \code{poly1} and \code{poly2} by swapping pointers 
    internally. 

void nmod_poly_zero(nmod_poly_t res)

    Sets \code{res} to the zero polynomial.

void nmod_poly_truncate(nmod_poly_t poly, long len)

    Truncates \code{poly} to the given length and normalises it. 
    If \code{len} is bigger than the current length of \code{poly}, 
    then nothing happens.

void _nmod_poly_reverse(mp_ptr output, mp_srcptr input, long len, long m)

    Set \code{output} to the reverse of \code{input}, which is of length
    \code{len}, but thinking of it as a polynomial of length \code{m} 
    (notionally zero padded if necessary). The length \code{m} must be 
    non-negative, but there are no other restrictions. The polynomial
    \code{output} must have space for \code{m} coefficients. 

void nmod_poly_reverse(nmod_poly_t output, const nmod_poly_t input, long m)

    Set \code{output} to the reverse of \code{input}, thinking of it as
    a polynomial of length \code{m} (notionally zero padded if necessary).
    The length \code{m} must be non-negative, but there are no other
    restrictions. The output polynomial will be set to length \code{m}
    and then normalised.

*******************************************************************************

    Randomisation

*******************************************************************************

void nmod_poly_randtest(nmod_poly_t poly, flint_rand_t state, long len)

    Generates a random polynomial with up to the given length.

*******************************************************************************

    Getting and setting coefficients

*******************************************************************************

ulong nmod_poly_get_coeff_ui(const nmod_poly_t poly, ulong j)

    Gets the coefficient of \code{poly} at index \code{j}, where coefficients 
    are numbered with zero being the constant coefficient, and returns it as 
    a \code{ulong}. If \code{j} refers to a coefficient beyond the end of 
    \code{poly}, zero is returned.

void nmod_poly_set_coeff_ui(nmod_poly_t poly, ulong j, ulong c)

    Sets the coefficient of \code{poly} at index \code{j}, where 
    coefficients are numbered with zero being the constant coefficient, 
    to the value \code{c} reduced modulo the modulus of \code{poly}. 
    If \code{j} refers to a coefficient beyond the current end of \code{poly}, 
    the polynomial is first resized, with intervening coefficients being
    set to zero.

*******************************************************************************

    Input and output

*******************************************************************************

char * nmod_poly_get_str(const nmod_poly_t poly)

    Writes \code{poly} to a string representation. The format is as 
    described for \code{nmod_poly_print}. The string must be freed by the 
    user when finished. For this it is sufficient to call \code{free}.

int nmod_poly_set_str(const char * s, nmod_poly_t poly)

    Read \code{poly} from a string \code{s}. The format is as described
    for \code{nmod_poly_print}. If a polynomial in the correct format
    is read, a positive value is returned, otherwise a non-positive value 
    is returned.

void nmod_poly_print(const nmod_poly_t a)

    Prints the polynomial to \code{stdout}. The length is printed, 
    followed by a space, then the modulus. If the length is zero this is
    all that is printed, otherwise two spaces followed by a space 
    separated list of coefficients is printed, beginning with the constant 
    coefficient.

int nmod_poly_fread(FILE * f, nmod_poly_t poly)

    Read \code{poly} from the file stream \code{f}. If this is a file
    that has just been written, the file should be closed then opened
    again. The format is as described for \code{nmod_poly_print}. If a 
    polynomial in the correct format is read, a positive value is returned, 
    otherwise a non-positive value is returned.

void nmod_poly_fprint(FILE * f, const nmod_poly_t poly)

    Write a polynomial to the file stream \code{f}. If this is a file
    then the file should be closed and reopened before being read.
    The format is as described for \code{nmod_poly_print}. If a 
    polynomial in the correct format is read, a positive value is returned, 
    otherwise a non-positive value is returned. If an error occurs 
    whilst writing to the file, an error message is printed.

int nmod_poly_read(nmod_poly_t poly)

    Read \code{poly} from \code{stdin}. The format is as described for 
    \code{nmod_poly_print}. If a polynomial in the correct format is read, a 
    positive value is returned, otherwise a non-positive value is returned.

*******************************************************************************

    Comparison

*******************************************************************************

int nmod_poly_equal(const nmod_poly_t a, const nmod_poly_t b)

    Returns $1$ if the polynomials are equal, otherwise $0$.

int nmod_poly_is_zero(const nmod_poly_t poly)

    Returns one if the polynomial \code{poly} is the zero polynomial,
    otherwise return zero.

*******************************************************************************

    Shifting

*******************************************************************************

void _nmod_poly_shift_left(mp_ptr res, mp_srcptr poly, long len, long k)

    Sets \code{(res, len + k)} to \code{(poly, len)} shifted left by 
    \code{k} coefficients. Assumes that \code{res} has space for 
    \code{len + k} coefficients.

void nmod_poly_shift_left(nmod_poly_t res, const nmod_poly_t poly, long k)

    Set \code{res} to \code{poly} shifted left by \code{k} coefficients, i.e.\ 
    multiplied by $x^k$.

void _nmod_poly_shift_right(mp_ptr res, mp_srcptr poly, long len, long k)

    Sets \code{(res, len - k)} to \code{(poly, len)} shifted left by 
    \code{k} coefficients. It is assumed that \code{k <= len} and that
    \code{res} has space for at least \code{len - k} coefficients.

void nmod_poly_shift_right(nmod_poly_t res, const nmod_poly_t poly, long k)

    Sets \code{res} to \code{poly} shifted right by \code{k} coefficients, 
    i.e.\ divide by $x^k$ and throws away the remainder. If \code{k} is 
    greater than or equal to the length of \code{poly}, the result is the 
    zero polynomial. 

*******************************************************************************

    Addition and subtraction

*******************************************************************************

void _nmod_poly_add(mp_ptr res, mp_srcptr poly1, long len1, 
                         mp_srcptr poly2, long len2, nmod_t mod)

    Sets \code{res} to the sum of \code{(poly1, len1)} and 
    \code{(poly2, len2)}. There are no restrictions on the lengths.

void nmod_poly_add(nmod_poly_t res, const nmod_poly_t poly1, 
                                            const nmod_poly_t poly2)

    Sets \code{res} to the sum of \code{poly1} and \code{poly2}.

void _nmod_poly_sub(mp_ptr res, mp_srcptr poly1, long len1, 
                         mp_srcptr poly2, long len2, nmod_t mod)

    Sets \code{res} to the difference of \code{(poly1, len1)} and 
    \code{(poly2, len2)}. There are no restrictions on the lengths.

void nmod_poly_sub(nmod_poly_t res, const nmod_poly_t poly1, 
                                    const nmod_poly_t poly2)

    Sets \code{res} to the difference of \code{poly1} and \code{poly2}.

void nmod_poly_neg(nmod_poly_t res, const nmod_poly_t poly1)

    Sets \code{res} to the negation of \code{poly1}.

*******************************************************************************

    Scalar multiplication and division

*******************************************************************************

void nmod_poly_scalar_mul_nmod(nmod_poly_t res, 
                          const nmod_poly_t poly1, ulong c)

    Sets \code{res} to \code{(poly1, len1)} multiplied by $c$, 
    where $c$ is reduced modulo the modulus of \code{poly1}.

void _nmod_poly_make_monic(mp_ptr output, 
                                      mp_srcptr input, long len, nmod_t mod)

    Sets \code{output} to be the scalar multiple of \code{input} of 
    length \code{len > 0} that has leading coefficient one, if such a 
    polynomial exists. If the leading coefficient of \code{input} is not
    invertible, \code{output} is set to the multiple of \code{input} whose
    leading coefficient is the greatest common divisor of the leading 
    coefficient and the modulus of \code{input}.

void nmod_poly_make_monic(nmod_poly_t output, const nmod_poly_t input)

    Sets \code{output} to be the scalar multiple of \code{input} with leading
    coefficient one, if such a polynomial exists. If \code{input} is zero
    an exception is raised. If the leading coefficient of \code{input} is not
    invertible, \code{output} is set to the multiple of \code{input} whose
    leading coefficient is the greatest common divisor of the leading 
    coefficient and the modulus of \code{input}.

*******************************************************************************

    Bit packing and unpacking

*******************************************************************************

void _nmod_poly_bit_pack(mp_ptr res, mp_srcptr poly, long len, 
                                                     mp_bitcnt_t bits)

    Packs \code{len} coefficients of \code{poly} into fields of the given 
    number of bits in the large integer \code{res}, i.e.\ evaluates 
    \code{poly} at \code{2^bits} and store the result in \code{res}. 
    Assumes \code{len > 0} and \code{bits > 0}. Also assumes that no 
    coefficient of \code{poly} is bigger than \code{bits/2} bits. We 
    also assume \code{bits < 3 * FLINT_BITS}.

void _nmod_poly_bit_unpack(mp_ptr res, long len, 
                                mp_srcptr mpn, ulong bits, nmod_t mod)

    Unpacks \code{len} coefficients stored in the big integer \code{mpn} 
    in bit fields of the given number of bits, reduces them modulo the 
    given modulus, then stores them in the polynomial \code{res}. 
    We assume \code{len > 0} and \code{3 * FLINT_BITS > bits > 0}.
    There are no restrictions on the size of the actual coefficients as 
    stored within the bitfields. 

*******************************************************************************

    Multiplication

*******************************************************************************

void _nmod_poly_mul_classical(mp_ptr res, mp_srcptr poly1, 
                    long len1, mp_srcptr poly2, long len2, nmod_t mod)

    Sets \code{(res, len1 + len2 - 1)} to the product of \code{(poly1, len1)}
    and \code{(poly2, len2)}. Assumes \code{len1 >= len2 > 0}. Aliasing of 
    inputs and output is not permitted.

void nmod_poly_mul_classical(nmod_poly_t res, 
                             const nmod_poly_t poly1, const nmod_poly_t poly2)

    Sets \code{res} to the product of \code{poly1} and \code{poly2}.

void _nmod_poly_mullow_classical(mp_ptr res, mp_srcptr poly1, long len1, 
                           mp_srcptr poly2, long len2, long trunc, nmod_t mod)

    Sets \code{res} to the lower \code{trunc} coefficients of the product of 
    \code{(poly1, len1)} and \code{(poly2, len2)}. Assumes that 
    \code{len1 >= len2 > 0} and \code{trunc > 0}. Aliasing of inputs and 
    output is not permitted.

void nmod_poly_mullow_classical(nmod_poly_t res, 
                  const nmod_poly_t poly1, const nmod_poly_t poly2, long trunc)

    Sets \code{res} to the lower \code{trunc} coefficients of the product 
    of \code{poly1} and \code{poly2}.

void _nmod_poly_mulhigh_classical(mp_ptr res, mp_srcptr poly1, 
            long len1, mp_srcptr poly2, long len2, long start, nmod_t mod)

    Computes the product of \code{(poly1, len1)} and \code{(poly2, len2)} 
    and writes the coefficients from \code{start} onwards into the high 
    coefficients of \code{res}, the remaining coefficients being arbitrary 
    but reduced.  Assumes that \code{len1 >= len2 > 0}. Aliasing of inputs 
    and output is not permitted.

void nmod_poly_mulhigh_classical(nmod_poly_t res, 
                  const nmod_poly_t poly1, const nmod_poly_t poly2, long start)

    Computes the product of \code{poly1} and \code{poly2} and writes the 
    coefficients from \code{start} onwards into the high coefficients of 
    \code{res}, the remaining coefficients being arbitrary but reduced.

void _nmod_poly_mul_KS(mp_ptr out, mp_srcptr in1, long len1, 
                     mp_srcptr in2, long len2, mp_bitcnt_t bits, nmod_t mod)

    Sets \code{res} to the product of \code{poly1} and \code{poly2} 
    assuming the output coefficients are at most the given number of 
    bits wide. If \code{bits} is set to $0$ an appropriate value is 
    computed automatically.  Assumes that \code{len1 >= len2 > 0}.

void nmod_poly_mul_KS(nmod_poly_t res, 
            const nmod_poly_t poly1, const nmod_poly_t poly2, mp_bitcnt_t bits)

    Sets \code{res} to the product of \code{poly1} and \code{poly2} 
    assuming the output coefficients are at most the given number of 
    bits wide. If \code{bits} is set to $0$ an appropriate value 
    is computed automatically.

void _nmod_poly_mullow_KS(mp_ptr out, mp_srcptr in1, long len1,
                mp_srcptr in2, long len2, mp_bitcnt_t bits, long n, nmod_t mod)

    Set \code{out} to the low $n$ coefficients of \code{in1} of length
    \code{len1} time \code{in2} of length \code{len2}. The output must have
    space for \code{n} coefficients. We assumed that \code{len1 >= len2 > 0}
    and that \code{0 < n <= len1 + len2 - 1}. 

void nmod_poly_mullow_KS(nmod_poly_t res, const nmod_poly_t poly1, 
                             const nmod_poly_t poly2, mp_bitcnt_t bits, long n)

    Set \code{res} to the low $n$ coefficients of \code{in1} of length
    \code{len1} time \code{in2} of length \code{len2}. 

void _nmod_poly_mul(mp_ptr res, mp_srcptr poly1, long len1, 
                                        mp_srcptr poly2, long len2, nmod_t mod)

    Sets \code{res} to the product of \code{poly1} of length \code{len1} 
    and \code{poly2} of length \code{len2}. Assumes \code{len1 >= len2 > 0}.
    No aliasing is permitted between the inputs and the output.

void nmod_poly_mul(nmod_poly_t res, 
                               const nmod_poly_t poly, const nmod_poly_t poly2)

    Sets \code{res} to the product of \code{poly1} and \code{poly2}.

void _nmod_poly_mullow(mp_ptr res, mp_srcptr poly1, long len1, 
                                mp_srcptr poly2, long len2, long n, nmod_t mod)

    Sets \code{res} to the first \code{n} coefficients of the 
    product of \code{poly1} of length \code{len1} and \code{poly2} of
    length \code{len2}. It is assumed that \code{0 < n <= len1 + len2 - 1} 
    and that \code{len1 >= len2 > 0}. No aliasing of inputs and output
    is permitted.

void nmod_poly_mullow(nmod_poly_t res, const nmod_poly_t poly1, 
                                           const nmod_poly_t poly2, long trunc)

    Sets \code{res} to the first \code{trunc} coefficients of the 
    product of \code{poly1} and \code{poly2}.

void _nmod_poly_mulhigh(mp_ptr res, mp_srcptr poly1, long len1, 
                                mp_srcptr poly2, long len2, long n, nmod_t mod)

    Sets all but the low $n$ coefficients of \code{res} to the 
    corresponding coefficients of the product of \code{poly1} of length 
    \code{len1} and \code{poly2} of length \code{len2}, the other 
    coefficients being arbitrary. It is assumed that 
    \code{len1 >= len2 > 0} and that \code{0 < n <= len1 + len2 - 1}. 
    Aliasing of inputs and output is not permitted.

void nmod_poly_mulhigh(nmod_poly_t res, const nmod_poly_t poly1, 
                                          const nmod_poly_t poly2, long n)

    Sets the all but the low $n$ coefficients of \code{res} to the 
    corresponding coefficients of the product of \code{poly1} and 
    \code{poly2}, the remaining coefficients being arbitrary.

*******************************************************************************

    Powering

*******************************************************************************

void _nmod_poly_pow_binexp(mp_ptr res, 
                             mp_srcptr poly, long len, ulong e, nmod_t mod)

    Raise \code{poly} of length \code{len} to the power \code{e} and set 
    \code{res} to the result. We require that \code{res} has enough space
    for \code{(len - 1)*e + 1)} coefficients. Assumes that \code{len > 0}, 
    \code{e > 1}. Aliasing is nor permitted. Uses the binary exponentiation
    method.

void nmod_poly_pow_binexp(nmod_poly_t res, const nmod_poly_t poly, ulong e)

    Raise \code{poly} to the power \code{e} and set \code{res} to the 
    result. Uses the binary exponentiation method.

void _nmod_poly_pow(mp_ptr res,
                             mp_srcptr poly, long len, ulong e, nmod_t mod)

    Raise \code{poly} of length \code{len} to the power \code{e} and set 
    \code{res} to the result. We require that \code{res} has enough space
    for \code{(len - 1)*e + 1)} coefficients. Assumes that \code{len > 0}, 
    \code{e > 1}. Aliasing is nor permitted. 

void nmod_poly_pow(nmod_poly_t res, const nmod_poly_t poly, ulong e)

    Raise \code{poly} to the power \code{e} and set \code{res} to the 
    result. 

void _nmod_poly_pow_trunc_binexp(mp_ptr res, mp_srcptr poly, 
                                           ulong e, long trunc, nmod_t mod)

    Set \code{res} to the low \code{trunc} coefficients of \code{poly}
    (assumed to be zero padded if necessary to length \code{trunc}) to 
    the power \code{e}. This is equivalent to doing a powering followed
    by a truncation. We require that \code{res} has enough space for
    \code{trunc} coefficients, that \code{trunc > 0} and that 
    \code{e > 1}. Aliasing is not permitted. Uses the binary 
    exponentiation method.

void nmod_poly_pow_trunc_binexp(nmod_poly_t res, 
                               const nmod_poly_t poly, ulong e, long trunc)

    Set \code{res} to the low \code{trunc} coefficients of \code{poly}
    to the power \code{e}. This is equivalent to doing a powering 
    followed by a truncation. Uses the binary exponentiation method.

void _nmod_poly_pow_trunc(mp_ptr res, mp_srcptr poly, 
                                           ulong e, long trunc, nmod_t mod)

    Set \code{res} to the low \code{trunc} coefficients of \code{poly}
    (assumed to be zero padded if necessary to length \code{trunc}) to 
    the power \code{e}. This is equivalent to doing a powering followed
    by a truncation. We require that \code{res} has enough space for
    \code{trunc} coefficients, that \code{trunc > 0} and that 
    \code{e > 1}. Aliasing is not permitted.

void nmod_poly_pow_trunc(nmod_poly_t res, 
                               const nmod_poly_t poly, ulong e, long trunc)

    Set \code{res} to the low \code{trunc} coefficients of \code{poly}
    to the power \code{e}. This is equivalent to doing a powering 
    followed by a truncation.

*******************************************************************************

    Division

*******************************************************************************

void _nmod_poly_divrem_basecase(mp_ptr Q, mp_ptr R, mp_ptr W, 
           mp_srcptr A, long A_len, mp_srcptr B, long B_len, nmod_t mod)

    Finds $Q$ and $R$ such that $A = B Q + R$ with $\len(R) < \len(B)$.
    If $\len(B) = 0$ an exception is raised. We require that \code{W}
    is temporary space of \code{NMOD_DIVREM_BC_ITCH(A_len, B_len, mod)}
    coefficients.

void nmod_poly_divrem_basecase(nmod_poly_t Q, 
                       nmod_poly_t R, const nmod_poly_t A, const nmod_poly_t B)

    Finds $Q$ and $R$ such that $A = B Q + R$ with $\len(R) < \len(B)$. 
    If $\len(B) = 0$ an exception is raised.

void _nmod_poly_div_basecase(mp_ptr Q, mp_ptr W, mp_srcptr A, long A_len, 
                                          mp_srcptr B, long B_len, nmod_t mod);

    Notionally finds polynomials $Q$ and $R$ such that $A = B Q + R$ with 
    $\len(R) < \len(B)$, but returns only \code{Q}. If $\len(B) = 0$ an 
    exception is raised. We require that \code{W} is temporary space of 
    \code{NMOD_DIV_BC_ITCH(A_len, B_len, mod)} coefficients.

void nmod_poly_div_basecase(nmod_poly_t Q, const nmod_poly_t A,
                                                          const nmod_poly_t B);

    Notionally finds polynomials $Q$ and $R$ such that $A = B Q + R$ with 
    $\len(R) < \len(B)$, but returns only \code{Q}. If $\len(B) = 0$ an 
    exception is raised.

void _nmod_poly_divrem_divconquer_recursive(mp_ptr Q, mp_ptr BQ, mp_ptr W,  
                     mp_ptr V, mp_srcptr A, mp_srcptr B, long lenB, nmod_t mod)

    Compute $Q$ and $R$ such that $A = BQ + R$ with \code{length(R) < lenB},
    where \code{A} is length \code{2 * lenB - 1} and \code{B} is length 
    \code{lenB}. Set \code{BQ} to the low \code{lenB - 1} coefficients of 
    \code{B * Q}. We require that \code{Q} have space for \code{lenB}
    coefficients and that \code{W} be temporary space of size \code{lenB - 1}
    and \code{V} be temporary space for a number of coefficients computed by
    \code{NMOD_DIVREM_DC_ITCH(lenB, mod)}. 

void _nmod_poly_divrem_divconquer(mp_ptr Q, mp_ptr R, 
                    mp_srcptr A, long lenA, mp_srcptr B, long lenB, nmod_t mod)

    Compute $Q$ and $R$ such that $A = BQ + R$ with \code{length(R) < lenB},
    where \code{A} is length \code{lenA} and \code{B} is length 
    \code{lenB}. We require that \code{Q} have space for \code{lenA - lenB + 1}
    coefficients. 

void nmod_poly_divrem_divconquer(nmod_poly_t Q, nmod_poly_t R,
                                      const nmod_poly_t A, const nmod_poly_t B)

    Compute \code{R} and \code{R} such that \code{A = BQ + R} with 
    \code{length(R) < length(B)}.

void _nmod_poly_divrem(mp_ptr Q, mp_ptr R, 
                    mp_srcptr A, long lenA, mp_srcptr B, long lenB, nmod_t mod)

    Compute $Q$ and $R$ such that $A = BQ + R$ with \code{length(R) < lenB},
    where \code{A} is length \code{lenA} and \code{B} is length 
    \code{lenB}. We require that \code{Q} have space for \code{lenA - lenB + 1}
    coefficients. 

void nmod_poly_divrem(nmod_poly_t Q, nmod_poly_t R,
                                      const nmod_poly_t A, const nmod_poly_t B)

    Compute \code{Q} and \code{R} such that \code{A = BQ + R} with 
    \code{length(R) < length(B)}.

void _nmod_poly_div_divconquer_recursive(mp_ptr Q, mp_ptr W, mp_ptr V,
                               mp_srcptr A, mp_srcptr B, long lenB, nmod_t mod)

    Compute $Q$ and $R$ such that $A = BQ + R$ with \code{length(R) < lenB},
    where \code{A} is length \code{2 * lenB - 1} and \code{B} is length 
    \code{lenB}. We require that \code{Q} have space for \code{lenB}
    coefficients and that \code{W} be temporary space of size \code{lenB - 1}
    and \code{V} be temporary space for a number of coefficients computed by
    \code{NMOD_DIV_DC_ITCH(lenB, mod)}. 

void _nmod_poly_div_divconquer(mp_ptr Q, mp_srcptr A, long lenA, 
                                            mp_srcptr B, long lenB, nmod_t mod)

    Notionally compute polynomials $Q$ and $R$ such that $A = BQ + R$ with
    \code{length(R) < lenB}, where \code{A} is length \code{lenA} and \code{B} 
    is length \code{lenB}, but return only \code{Q}. We require that \code{Q} 
    have space for \code{lenA - lenB + 1} coefficients.

void nmod_poly_div_divconquer(nmod_poly_t Q,
                                      const nmod_poly_t A, const nmod_poly_t B)

    Notionally compute \code{R} and \code{R} such that \code{A = BQ + R} 
    with \code{length(R) < length(B)}, but return only \code{Q}.

void _nmod_poly_div(mp_ptr Q, mp_srcptr A, long lenA, 
                                            mp_srcptr B, long lenB, nmod_t mod)

    Notionally compute polynomials $Q$ and $R$ such that $A = BQ + R$ with
    \code{length(R) < lenB}, where \code{A} is length \code{lenA} and \code{B} 
    is length \code{lenB}, but return only \code{Q}. We require that \code{Q} 
    have space for \code{lenA - lenB + 1} coefficients. 

void nmod_poly_div(nmod_poly_t Q, const nmod_poly_t A, const nmod_poly_t B)

    Notionally compute \code{R} and \code{R} such that \code{A = BQ + R} 
    with \code{length(R) < length(B)}, but return only \code{Q}.

void _nmod_poly_inv_series_basecase(mp_ptr Qinv, 
                                    mp_srcptr Q, long n, nmod_t mod)
    
    Given \code{Q} of length \code{n} whose leading coefficient is invertible
    modulo the given modulus, find a polynomial \code{Qinv} of length \code{n}
    such that the top \code{n} coefficients of the product \code{Q * Qinv} is
    $x^{n - 1}$. Requires that \code{n > 0}. This function can be viewed as 
    inverting a power series.

void nmod_poly_inv_series_basecase(nmod_poly_t Qinv, 
                                   const nmod_poly_t Q, long n)

    Given \code{Q} of length at least \code{n} find \code{Qinv} of length
    \code{n} such that the top \code{n} coefficients of the product 
    \code{Q * Qinv} is $x^{n - 1}$. An exception is raised if \code{n = 0}
    or if the length of \code{Q} is less than \code{n}. The leading 
    coefficient of \code{Q} must be invertible modulo the modulus of 
    \code{Q}. This function can be viewed as inverting a power series.

void _nmod_poly_inv_series_newton(mp_ptr Qinv, mp_srcptr Q, long n, nmod_t mod)
    
    Given \code{Q} of length \code{n} whose constant coefficient is invertible
    modulo the given modulus, find a polynomial \code{Qinv} of length \code{n}
    such that \code{Q * Qinv} is \code{1} modulo $x^n$. Requires \code{n > 0}.
    This function can be viewed as inverting a power series via Newton 
    iteration.

void nmod_poly_inv_series_newton(nmod_poly_t Qinv, const nmod_poly_t Q, long n)

    Given \code{Q} find \code{Qinv} such that \code{Q * Qinv} is \code{1}
    modulo $x^n$. The constant coefficient of \code{Q} must be invertible 
    modulo the modulus of \code{Q}. An exception is raised if this is not
    the case or if \code{n = 0}. This function can be viewed as inverting 
    a power series via Newton iteration.

void _nmod_poly_inv_series(mp_ptr Qinv, mp_srcptr Q, long n, nmod_t mod)
    
    Given \code{Q} of length \code{n} whose constant coefficient is invertible
    modulo the given modulus, find a polynomial \code{Qinv} of length \code{n}
    such that \code{Q * Qinv} is \code{1} modulo $x^n$. Requires \code{n > 0}.
    This function can be viewed as inverting a power series.

void nmod_poly_inv_series(nmod_poly_t Qinv, const nmod_poly_t Q, long n)

    Given \code{Q} find \code{Qinv} such that \code{Q * Qinv} is \code{1}
    modulo $x^n$. The constant coefficient of \code{Q} must be invertible 
    modulo the modulus of \code{Q}. An exception is raised if this is not
    the case or if \code{n = 0}. This function can be viewed as inverting 
    a power series.

void _nmod_poly_div_series(mp_ptr Q, mp_srcptr A, mp_srcptr B, 
                                                  long n, nmod_t mod)

    Given polynomials \code{A} and \code{B} of length \code{n}, finds the
    polynomial \code{Q} of length \code{n} such that \code{Q * B = A}
    modulo $x^n$. We assume \code{n > 0} and that the constant coefficient 
    of \code{B} is invertible modulo the given modulus. The polynomial 
    \code{Q} must have space for \code{n} coefficients.

void nmod_poly_div_series(nmod_poly_t Q, const nmod_poly_t A, 
                                         const nmod_poly_t B, long n)

    Given polynomials \code{A} and \code{B} considered modulo \code{n}, 
    finds the polynomial \code{Q} of length at most \code{n} such that
    \code{Q * B = A} modulo $x^n$. We assume \code{n > 0} and that the
    constant coefficient of \code{B} is invertible modulo the modulus. 
    An exception is raised if \code{n == 0} or the constant coefficient
    of \code{B} is zero.

void _nmod_poly_div_newton(mp_ptr Q, mp_srcptr A, long Alen, 
                                     mp_srcptr B, long Blen, nmod_t mod)

    Notionally compute polynomials $Q$ and $R$ such that $A = BQ + R$ with
    \code{length(R) < lenB}, where \code{A} is length \code{lenA} and \code{B} 
    is length \code{lenB}, but return only \code{Q}. We require that \code{Q} 
    have space for \code{lenA - lenB + 1} coefficients. The algorithm used is 
    to reverse the polynomials and divde the resulting power series, then 
    reverse the result.

void nmod_poly_div_newton(nmod_poly_t Q, const nmod_poly_t A,
                                         const nmod_poly_t B)

    Notionally compute \code{R} and \code{R} such that \code{A = BQ + R} 
    with \code{length(R) < length(B)}, but return only \code{Q}. The algorithm 
    used is to reverse the polynomials and divde the resulting power series, 
    then reverse the result.

void _nmod_poly_divrem_newton(mp_ptr Q, mp_ptr R, mp_srcptr A, long Alen, 
                                        mp_srcptr B, long Blen, nmod_t mod)

    Compute $Q$ and $R$ such that $A = BQ + R$ with \code{length(R) < lenB},
    where \code{A} is length \code{lenA} and \code{B} is length \code{lenB}. 
    We require that \code{Q} have space for \code{lenA - lenB + 1}
    coefficients. The algorithm used is to call \code{div_newton} and then
    multiply out and compute the remainder. 

void nmod_poly_divrem_newton(nmod_poly_t Q, nmod_poly_t R, 
                             const nmod_poly_t A, const nmod_poly_t B)

    Compute \code{Q} and \code{R} such that \code{A = BQ + R} with 
    $\len(R) < \len(B)$.  The algorithm used is to call \code{div_newton} 
    and then multiply out and compute the remainder.

*******************************************************************************

    Derivative

*******************************************************************************

void _nmod_poly_derivative(mp_ptr x_prime, mp_srcptr x, long len, nmod_t mod)

    Set the first \code{len - 1} coefficients of \code{x_prime} to the 
    derivative of \code{x} which is assumed to be of length \code{len}. 
    It is assumed that \code{len > 0}.

void nmod_poly_derivative(nmod_poly_t x_prime, const nmod_poly_t x)

    Set \code{x_prime} to the derivative of \code{x}. 

*******************************************************************************

    Evaluation

*******************************************************************************

mp_limb_t _nmod_poly_evaluate_nmod(mp_srcptr poly, long len, mp_limb_t c, 
                                   nmod_t mod)

    Evaluate \code{poly} at the value \code{c} and reduce modulo the 
    given modulus (of \code{poly}). The value \code{c} should be reduced 
    modulo the modulus. The algorithm used is Horner's method.

mp_limb_t nmod_poly_evaluate_nmod(nmod_poly_t poly, mp_limb_t c)

    Evaluate \code{poly} at the value \code{c} and reduce modulo the 
    modulus of \code{poly}. The value \code{c} should be reduced modulo
    the modulus. The algorithm used is Horner's method.

*******************************************************************************

    Composition

*******************************************************************************

void _nmod_poly_compose_horner(mp_ptr res, mp_srcptr poly1, long len1, 
                               mp_srcptr poly2, long len2, nmod_t mod)

    Compose \code{poly1} of length \code{len1} with \code{poly2} of length 
    \code{len2} and set \code{res} to the result, i.e. evaluate \code{poly1} 
    at \code{poly2}. The algorithm used is Horner's algorithm. We require 
    that \code{res} have space for \code{(len1 - 1)*(len2 - 1) + 1} 
    coefficients. It is assumed that \code{len1 > 0} and \code{len2 > 0}.

void nmod_poly_compose_horner(nmod_poly_t res, 
                              const nmod_poly_t poly1, const nmod_poly_t poly2)

    Compose \code{poly1} with \code{poly2} and set \code{res} to the result,
    i.e.\ evaluate \code{poly1} at \code{poly2}. The algorithm used is 
    Horner's algorithm.

void _nmod_poly_compose_divconquer(mp_ptr res, mp_srcptr poly1, long len1, 
                                   mp_srcptr poly2, long len2, nmod_t mod)

    Compose \code{poly1} of length \code{len1} with \code{poly2} of length 
    \code{len2} and set \code{res} to the result, i.e. evaluate \code{poly1} 
    at \code{poly2}. The algorithm used is the divide and conquer algorithm. 
    We require that \code{res} have space for \code{(len1 - 1)*(len2 - 1) + 1} 
    coefficients. It is assumed that \code{len1 > 0} and \code{len2 > 0}.

void nmod_poly_compose_divconquer(nmod_poly_t res, 
                              const nmod_poly_t poly1, const nmod_poly_t poly2)

    Compose \code{poly1} with \code{poly2} and set \code{res} to the result,
    i.e. evaluate \code{poly1} at \code{poly2}. The algorithm used is 
    the divide and conquer algorithm.

void _nmod_poly_compose(mp_ptr res, mp_srcptr poly1, long len1, 
                                        mp_srcptr poly2, long len2, nmod_t mod)

    Compose \code{poly1} of length \code{len1} with \code{poly2} of length 
    \code{len2} and set \code{res} to the result, i.e. evaluate \code{poly1} 
    at \code{poly2}. We require that \code{res} have space for 
    \code{(len1 - 1)*(len2 - 1) + 1} coefficients. It is assumed that 
    \code{len1 > 0} and \code{len2 > 0}.

void nmod_poly_compose(nmod_poly_t res, 
                              const nmod_poly_t poly1, const nmod_poly_t poly2)

    Compose \code{poly1} with \code{poly2} and set \code{res} to the result,
    that is evaluate \code{poly1} at \code{poly2}.

*******************************************************************************

    GCD

*******************************************************************************

long _nmod_poly_gcd_euclidean(mp_ptr G, 
                    mp_srcptr A, long lenA, mp_srcptr B, long lenB, nmod_t mod)

    Compute the GCD of \code{A} of length \code{lenA} and \code{B} of length
    \code{lenB}, where \code{lenA >= lenB > 1}. The length of the GCD \code{G}
    is returned by the function. No attempt is made to make the GCD monic. It
    is required that \code{G} have space for \code{lenB} coefficients.

void nmod_poly_gcd_euclidean(nmod_poly_t G, 
                             const nmod_poly_t A, const nmod_poly_t B)

    Compute the GCD of \code{A} and \code{B}. The GCD of zero polynomials is
    defined to be zero, whereas the GCD of the zero polynomial and some other
    polynomial \code{P} is defined to be \code{P}. Except in the case where
    the GCD is zero, the GCD \code{G} is made monic.

